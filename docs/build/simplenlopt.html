

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>simplenlopt package &mdash; simplenlopt 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Curve Fitting" href="Curve_Fitting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> simplenlopt
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Constrained_Optimization.html">Constrained optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Global_Opt.html">Global Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="InDepth_Gradients.html">In depth: Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="Curve_Fitting.html">Curve Fitting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">simplenlopt package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-simplenlopt">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">simplenlopt</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>simplenlopt package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/simplenlopt.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="simplenlopt-package">
<h1>simplenlopt package<a class="headerlink" href="#simplenlopt-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-simplenlopt">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-simplenlopt" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="simplenlopt.auglag">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">auglag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">jac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">penalize_inequalities</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.auglag" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrained local minimization via the augmented lagrangian method</p>
<p>References:</p>
<p>Andrew R. Conn, Nicholas I. M. Gould, and Philippe L. Toint,
“A globally convergent augmented Lagrangian algorithm for optimization
with general constraints and simple bounds,” SIAM J. Numer. Anal. vol. 28, no. 2, p. 545-572 (1991)</p>
<p>E. G. Birgin and J. M. Martínez, “Improving ultimate convergence of an augmented Lagrangian method,”
Optimization Methods and Software vol. 23, no. 2, p. 177-195 (2008)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>x0</strong> (<em>ndarray</em>) – Starting guess for the decision variable</p></li>
<li><p><strong>args</strong> (<em>tuple</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>method</strong> (<em>string</em><em> or </em><em>'auto'</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – <p>Optimization algorithm to use. If string, should be one of</p>
<blockquote>
<div><ul>
<li><p>’lbfgs’</p></li>
<li><p>’slsqp’</p></li>
<li><p>’mma’</p></li>
<li><p>’ccsaq’</p></li>
<li><p>’tnewton’</p></li>
<li><p>’tnewton_restart’</p></li>
<li><p>’tnewton_precond’</p></li>
<li><p>’precond_restart’</p></li>
<li><p>’var1’</p></li>
<li><p>’var2’</p></li>
<li><p>’bobyqa’</p></li>
<li><p>’cobyla’</p></li>
<li><p>’neldermead’</p></li>
<li><p>’sbplx’</p></li>
<li><p>’praxis’</p></li>
<li><p>’newuoa_bound’</p></li>
<li><p>’newuoa’</p></li>
</ul>
</div></blockquote>
<p>If ‘auto’, a suitable solver is chosen based on the availability
of gradient information and if also inequalities should be penalized:</p>
<p>jac != None and penalize_inequalities=True -&gt; ‘lbfgs’</p>
<p>jac = None and penalize_inequalities=True -&gt; ‘bobyqa’</p>
<p>jac != None and penalize_inequalities=False -&gt; ‘mma’</p>
<p>jac = None and penalize_inequalities=False -&gt; ‘cobyla’</p>
</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>,
defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>.
It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – List of constraint functions. Constraints must be of the form <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> for a constraint of the form f(x) &lt;= 0.</p></li>
<li><p><strong>penalize_inequalities</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – If True, also penalizes violation of inequality constraints (NLopt code: AUGLAG).
If False, only penalizes violation of equality constraints (NLopt code: AUGLAG_EQ).
In this case the chosen method must be able to handle inequality constraints.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
<li><p><strong>version of augmented lagrangian</strong> (<em>#choose</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.crs">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">crs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">'random'</span></em>, <em class="sig-param"><span class="n">population</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.crs" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via Controlled Random Search with local mutation</p>
<p>References:</p>
<p>P. Kaelo and M. M. Ali, “Some variants of the controlled random search algorithm
for global optimization,” J. Optim. Theory Appl. 130 (2), 253-264 (2006)</p>
<p>W. L. Price, “Global optimization by controlled random search,”
J. Optim. Theory Appl. 40 (3), p. 333-348 (1983)</p>
<p>W. L. Price, “A controlled random search procedure for global optimization,”
in Towards Global Optimization 2, p. 71-84 edited by L. C. W. Dixon and G. P. Szego
(North-Holland Press, Amsterdam, 1978)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>x0</strong> (<em>{ndarray</em><em>, </em><em>'random'}</em><em>, </em><em>optional</em><em>, </em><em>default 'random'</em>) – Initial parameter vector guess.
If ndarray, must be a 1-D array
if ‘random’, picks a random initial guess in the feasible region.</p></li>
<li><p><strong>population</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Population size.
If None, will use NLopt’s default population size.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.curve_fit">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">curve_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">xdata</span></em>, <em class="sig-param"><span class="n">ydata</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loss</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">jac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">minimize_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.curve_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Curve fitting using NLopt’s local optimizers in SciPy style</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>callable</em>) – Must be of the form <code class="docutils literal notranslate"><span class="pre">f(xdata,</span> <span class="pre">*params)</span></code></p></li>
<li><p><strong>xdata</strong> (<em>ndarray</em><em> (</em><em>n</em><em>, </em><em>)</em>) – Predictor variable values</p></li>
<li><p><strong>ydata</strong> (<em>ndarray</em><em> (</em><em>n</em><em>, </em><em>)</em>) – Response variable values</p></li>
<li><p><strong>p0</strong> (<em>ndarray</em><em> (</em><em>n</em><em>, </em><em>)</em><em>, </em><em>optional</em>) – If None, defaults to 1 for all parameters</p></li>
<li><p><strong>sigma</strong> (<em>ndarray</em><em> (</em><em>n</em><em>, </em><em>)</em><em>, </em><em>optional</em>) – Typically uncertainties for each data point. The objective will be multiplied by 1/sigma</p></li>
<li><p><strong>bounds</strong> (<em>two-tuple of array-like</em><em>, </em><em>optional</em>) – Determines the bounds on the fitting parameters ([lower_bounds], [upper_bounds])</p></li>
<li><p><strong>loss</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default 'linear'</em>) – <p>Should be one of</p>
<blockquote>
<div><ul>
<li><p>’linear’ (yields squared residuals)</p></li>
<li><p>’absolute’ (minimizes absolute residuals)</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>method</strong> (<em>string</em><em> or </em><em>'auto'</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – <p>Optimization algorithm to use. If string, Should be one of</p>
<blockquote>
<div><ul>
<li><p>’lbfgs’</p></li>
<li><p>’slsqp’</p></li>
<li><p>’mma’</p></li>
<li><p>’ccsaq’</p></li>
<li><p>’tnewton’</p></li>
<li><p>’tnewton_restart’</p></li>
<li><p>’tnewton_precond’</p></li>
<li><p>’precond_restart’</p></li>
<li><p>’var1’</p></li>
<li><p>’var2’</p></li>
<li><p>’bobyqa’</p></li>
<li><p>’cobyla’</p></li>
<li><p>’neldermead’</p></li>
<li><p>’sbplx’</p></li>
<li><p>’praxis’</p></li>
<li><p>’newuoa_bound’</p></li>
<li><p>’newuoa’</p></li>
</ul>
</div></blockquote>
<p>If ‘auto’, defaults to ‘slsqp’ if jac != None and ‘bobyqa’ if jac = None</p>
</p></li>
<li><p><strong>jac</strong> (<em>callable</em><em>, </em><em>optional</em>) – Must be of the form <code class="docutils literal notranslate"><span class="pre">jac(xdata)</span></code> and return a N x m numpy array for
N data points and m fitting parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.direct">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">locally_biased</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">randomize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">original</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via variants of the DIviding RECTangles (DIRECT) algorithm</p>
<p>Default variant: DIRECT_L</p>
<p>References:
D. R. Jones, C. D. Perttunen, and B. E. Stuckmann, “Lipschitzian optimization without
the lipschitz constant,” J. Optimization Theory and Applications, vol. 79, p. 157 (1993)</p>
<p>J. M. Gablonsky and C. T. Kelley, “A locally-biased form of the DIRECT algorithm,”
J. Global Optimization, vol. 21 (1), p. 27-37 (2001)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>locally_biased</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – If True, uses the locally biased variant of DIRECT known as DIRECT_L</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – If True, scales the parameter space to a hypercube of length 1 in all dimensions</p></li>
<li><p><strong>randomize</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default False</em>) – If True, randomize the algorithm by partly randomizing which side of the hyperrectangle is halved</p></li>
<li><p><strong>original</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default False</em>) – If True, applies the original implementation of DIRECT by Jablonsky</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.esch">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">esch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">'random'</span></em>, <em class="sig-param"><span class="n">population</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.esch" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via Differential Evolution variant</p>
<p>NOTE: ESCH does not seem to respect the relative and absolute convergence criteria.
By default, it will always run for the maximal number of iterations.</p>
<p>Reference:
C. H. da Silva Santos, “Parallel and Bio-Inspired Computing Applied
to Analyze Microwave and Photonic Metamaterial Strucutures,”
Ph.D. thesis, University of Campinas, (2010)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>x0</strong> (<em>{ndarray</em><em>, </em><em>'random'}</em><em>, </em><em>optional</em><em>, </em><em>default 'random'</em>) – Initial parameter vector guess.
If ndarray, must be a 1-D array
if ‘random’, picks a random initial guess in the feasible region.</p></li>
<li><p><strong>population</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Population size.
If None, will use NLopt’s default population size.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.global_optimizers_info">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">global_optimizers_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.global_optimizers_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a short summary of NLopt’s global optimizers</p>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.isres">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">isres</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">'random'</span></em>, <em class="sig-param"><span class="n">population</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.isres" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via the Improved Stochastic Ranking Evolution Strategy</p>
<p>NOTE: IRES does not seem to respect the relative and absolute convergence criteria.
By default, it will always run for the maximal number of iterations.</p>
<p>References:</p>
<p>Thomas Philip Runarsson and Xin Yao, “Search biases in constrained evolutionary optimization,”
IEEE Trans. on Systems, Man, and Cybernetics Part C: Applications and Reviews,
vol. 35 (no. 2), pp. 233-243 (2005)</p>
<p>Thomas P. Runarsson and Xin Yao, “Stochastic ranking for constrained evolutionary optimization,”
IEEE Trans. Evolutionary Computation, vol. 4 (no. 3), pp. 284-294 (2000)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – List of constraint functions. Constraints must be of the form <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> for a constraint of the form f(x) &lt;= 0.</p></li>
<li><p><strong>x0</strong> (<em>{ndarray</em><em>, </em><em>'random'}</em><em>, </em><em>optional</em><em>, </em><em>default 'random'</em>) – Initial parameter vector guess.
If ndarray, must be a 1-D array
if ‘random’, picks a random initial guess in the feasible region.</p></li>
<li><p><strong>population</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Population size.
If None, will use NLopt’s default population size.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.local_optimizers_info">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">local_optimizers_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.local_optimizers_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a short summary of NLopt’s local optimizers</p>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.minimize">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">minimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">jac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Local minimization function for NLopt’s algorithm in SciPy style</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>x0</strong> (<em>ndarray</em>) – Starting guess for the decision variable</p></li>
<li><p><strong>args</strong> (<em>tuple</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>method</strong> (<em>string</em><em> or </em><em>'auto'</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – <p>Optimization algorithm to use. If string, Should be one of</p>
<blockquote>
<div><ul>
<li><p>’lbfgs’</p></li>
<li><p>’slsqp’</p></li>
<li><p>’mma’</p></li>
<li><p>’ccsaq’</p></li>
<li><p>’tnewton’</p></li>
<li><p>’tnewton_restart’</p></li>
<li><p>’tnewton_precond’</p></li>
<li><p>’precond_restart’</p></li>
<li><p>’var1’</p></li>
<li><p>’var2’</p></li>
<li><p>’bobyqa’</p></li>
<li><p>’cobyla’</p></li>
<li><p>’neldermead’</p></li>
<li><p>’sbplx’</p></li>
<li><p>’praxis’</p></li>
<li><p>’newuoa_bound’</p></li>
<li><p>’newuoa’</p></li>
</ul>
</div></blockquote>
<p>If ‘auto’, will be set to ‘bobyqa’/’cobyla’ if jac=None (‘cobyla’ if constraints are set)
or ‘lbfgs’/’slsqp’ if jac != None (‘slsqp’ if constraints set)</p>
<p>If the chosen method does not support the required constraints, the augmented lagrangian
is called to handle them.</p>
</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>,
defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>.
It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – List of constraint functions. Constraints must be of the form <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> for a constraint of the form f(x) &lt;= 0.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">rosen</span><span class="p">,</span> <span class="n">rosen_der</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">success</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">message</span>
<span class="go">&#39;Success&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">ftol_abs</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">success</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">message</span>
<span class="go">&#39;Optimization stopped because ftol_rel or ftol_abs (above) was reached.&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">Parameter foo could not be recognized.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cons</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>          <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">dfun</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;slsqp&#39;</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">success</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">message</span>
<span class="go">&#39;Halted because roundoff errors limited progress. (In this case, the optimization still typically returns a useful result.)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([ 0.84,  0.6 ])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cons</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;some bogus type&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>          <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>          <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">dfun</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;slsqp&#39;</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span> <span class="n">ftol_abs</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">Constraint type not recognized</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.mlsl">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">mlsl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">jac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">'random'</span></em>, <em class="sig-param"><span class="n">sobol_sampling</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">population</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">local_minimizer</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">local_minimizer_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.mlsl" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via MultiLevel Single Linkage (MLSL)</p>
<p>MLSL works by performing repeated local minimizations and heuristic rules to avoid
repeated searches of the same areas of the parameter space.</p>
<p>NOTE: MLSL does not seem to respect the relative and absolute convergence criteria.
By default, it will always run for the maximal number of iterations.</p>
<p>References:</p>
<p>A. H. G. Rinnooy Kan and G. T. Timmer, “Stochastic global optimization methods,”
Mathematical Programming, vol. 39, p. 27-78 (1987)</p>
<p>Sergei Kucherenko and Yury Sytsko, “Application of deterministic low-discrepancy sequences
in global optimization,” Computational Optimization and Applications, vol. 30, p. 297-318 (2005)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>jac</strong> (<em>{callable</em><em>,  </em><em>'2-point'</em><em>, </em><em>'3-point'</em><em>, </em><em>'NLOpt'</em><em>, </em><em>bool}</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – If callable, must be in the form <code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument
in the form of a 1-D array and args is a tuple of any additional fixed parameters
needed to completely specify the function
If ‘2-point’ will use forward difference to approximate the gradient
If ‘3-point’ will use central difference to approximate the gradient
If ‘NLOpt’, must be in the form <code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">grad,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument
in the form of a 1-D array, <code class="docutils literal notranslate"><span class="pre">grad</span></code> a 1-D array containing the gradient
and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>x0</strong> (<em>{ndarray</em><em>, </em><em>'random'}</em><em>, </em><em>optional</em><em>, </em><em>default 'random'</em>) – Initial parameter vector guess.
If ndarray, must be a 1-D array
if ‘random’, picks a random initial guess in the feasible region.</p></li>
<li><p><strong>sobol_sampling</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – If True, starting points for local minimizations are sampled from a Sobol sequence.</p></li>
<li><p><strong>population</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 4</em>) – Number of local searches per iteration.</p></li>
<li><p><strong>local_minimizer</strong> (<em>{str</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default = 'auto'</em>) – Local minimizer used. If ‘auto’, either LBFGS if gradient is supplied or BOBYQA if
no gradient is supplied. If string, must be one of the local minimizers that can be fed
to <code class="docutils literal notranslate"><span class="pre">minimize</span></code>.</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>1e-8</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions for gradient based local optimizer,
and 10.000 * problem dimensional for gradient free local optimizer</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated</p></li>
<li><p><strong>local_mimimizer_options</strong> (<em>dict</em>) – Further options supplied to the local minimizer</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="simplenlopt.stogo">
<code class="sig-prename descclassname">simplenlopt.</code><code class="sig-name descname">stogo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">args</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">jac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">'random'</span></em>, <em class="sig-param"><span class="n">randomize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ftol_rel</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">xtol_rel</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ftol_abs</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">xtol_abs</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">maxeval</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">maxtime</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver_options</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#simplenlopt.stogo" title="Permalink to this definition">¶</a></dt>
<dd><p>Global optimization via STOchastic Global Optimization (STOGO)</p>
<p>NOTE: STOGO does not seem to respect the relative and absolute convergence criteria.
By default, it will always run for the maximal number of iterations.</p>
<p>References:</p>
<p>S. Zertchaninov and K. Madsen, “A C++ Programme for Global Optimization,”
IMM-REP-1998-04, Department of Mathematical Modelling,
Technical University of Denmark, DK-2800 Lyngby, Denmark, 1998</p>
<p>S. Gudmundsson, “Parallel Global Optimization,” M.Sc. Thesis, IMM,
Technical University of Denmark, 1998</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> (<em>callable</em>) – The objective function to be minimized. Must be in the form <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function</p></li>
<li><p><strong>bounds</strong> (<em>tuple of array-like</em>) – Bounds for variables. <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining the finite lower and upper bounds for the optimizing argument of <code class="docutils literal notranslate"><span class="pre">fun</span></code>. It is required to have <code class="docutils literal notranslate"><span class="pre">len(bounds)</span> <span class="pre">==</span> <span class="pre">len(x)</span></code>. <code class="docutils literal notranslate"><span class="pre">len(bounds)</span></code> is used to determine the number of parameters in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>args</strong> (<em>list</em><em>, </em><em>optional</em><em>, </em><em>default</em><em> (</em><em>)</em>) – Further arguments to describe the objective function</p></li>
<li><p><strong>jac</strong> (<em>{callable</em><em>,  </em><em>'2-point'</em><em>, </em><em>'3-point'</em><em>, </em><em>'NLOpt'</em><em>, </em><em>bool}</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – <p>If callable, must be in the form <code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument
in the form of a 1-D array and args is a tuple of any additional fixed parameters
needed to completely specify the function</p>
<p>If ‘2-point’ will use forward difference to approximate the gradient</p>
<p>If ‘3-point’ will use central difference to approximate the gradient</p>
<p>If ‘NLOpt’, must be in the form <code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">grad,</span> <span class="pre">*args)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the argument
in the form of a 1-D array, <code class="docutils literal notranslate"><span class="pre">grad</span></code> a 1-D array containing the gradient
and args is a tuple of any additional fixed parameters needed to completely specify the function</p>
</p></li>
<li><p><strong>x0</strong> (<em>{ndarray</em><em>, </em><em>'random'}</em><em>, </em><em>optional</em><em>, </em><em>default 'random'</em>) – <p>Initial parameter vector guess.</p>
<p>If ndarray, must be a 1-D array</p>
<p>If ‘random’, picks a random initial guess in the feasible region.</p>
</p></li>
<li><p><strong>randomize</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default False</em>) – If True, randomizes the branching process</p></li>
<li><p><strong>ftol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Relative function tolerance to signal convergence</p></li>
<li><p><strong>xtol_rel</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-6</em>) – Relative parameter vector tolerance to signal convergence</p></li>
<li><p><strong>ftol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-14</em>) – Absolute function tolerance to signal convergence</p></li>
<li><p><strong>xtol_abs</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default 1e-8</em>) – Absolute parameter vector tolerance to signal convergence</p></li>
<li><p><strong>maxeval</strong> (<em>{int</em><em>, </em><em>'auto'}</em><em>, </em><em>optional</em><em>, </em><em>default 'auto'</em>) – Number of maximal function evaluations.
If ‘auto’, set to 1.000 * dimensions</p></li>
<li><p><strong>maxtime</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – maximum absolute time until the optimization is terminated.</p></li>
<li><p><strong>solver_options</strong> (<em>dict</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – Dictionary of additional options supplied to the solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>opt_result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Curve_Fitting.html" class="btn btn-neutral float-left" title="Curve Fitting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Daniel Schmitz.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>